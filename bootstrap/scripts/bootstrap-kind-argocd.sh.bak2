#!/usr/bin/env bash
set -euo pipefail

# Comprehensive GitOps Platform Bootstrap Script
# Integrates features from gitops-multicluster-get-started
CLUSTER_NAME=${1:-demo}
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
KUBECONFIG_PATH="${REPO_ROOT}/bootstrap/${CLUSTER_NAME}.kubeconfig"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Banner
print_banner() {
    cat << "EOF"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘          GitOps Multi-Cluster Platform                   â•‘
â•‘          Interactive Bootstrap Tool                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
}

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."
    
    local missing_tools=()
    
    # Essential tools
    command -v kubectl >/dev/null 2>&1 || missing_tools+=("kubectl")
    command -v kind >/dev/null 2>&1 || missing_tools+=("kind")
    command -v docker >/dev/null 2>&1 || missing_tools+=("docker")
    command -v git >/dev/null 2>&1 || missing_tools+=("git")
    
    if [ ${#missing_tools[@]} -ne 0 ]; then
        log_error "Missing required tools: ${missing_tools[*]}"
        log_info "Please install the missing tools and try again."
        exit 1
    fi
    
    # Check Docker is running
    if ! docker info >/dev/null 2>&1; then
        log_error "Docker is not running. Please start Docker and try again."
        exit 1
    fi
    
    log_success "All prerequisites met!"
}

# Interactive configuration
configure_deployment() {
    log_info "Deployment Configuration"
    echo ""
    
    # Multi-environment setup
    echo "Do you want to set up multiple environments?"
    echo "  1) Single cluster (dev only)"
    echo "  2) Multi-environment (dev, staging, prod)"
    read -p "Choice [1]: " ENV_SETUP
    ENV_SETUP=${ENV_SETUP:-1}
    
    # ArgoCD server configuration
    echo ""
    echo "ArgoCD server configuration:"
    echo "  1) Insecure server (easier for local development)"
    echo "  2) Secure server (production-like setup)"
    read -p "Choice [1]: " ARGOCD_SECURE
    ARGOCD_SECURE=${ARGOCD_SECURE:-1}
    
    # Demo applications
    echo ""
    echo "Deploy demo applications:"
    echo "  1) Guestbook only"
    echo "  2) Full demo suite (guestbook + monitoring)"
    read -p "Choice [1]: " DEMO_APPS
    DEMO_APPS=${DEMO_APPS:-1}
    
    echo ""
    log_success "Configuration complete!"
}

# Create KIND cluster with enhanced configuration
create_kind_cluster() {
    local cluster_name="$1"
    
    log_info "Creating KIND cluster: $cluster_name"
    
    # Check if cluster already exists
    if kind get clusters | grep -q "^${cluster_name}$"; then
        log_warn "Cluster '$cluster_name' already exists!"
        read -p "Delete and recreate? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            log_info "Deleting existing cluster..."
            kind delete cluster --name "$cluster_name"
        else
            log_info "Using existing cluster..."
            return 0
        fi
    fi
    
    # Enhanced KIND configuration with port mappings
    cat <<EOF | kind create cluster --name "$cluster_name" --config=-
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
  - role: control-plane
    kubeadmConfigPatches:
    - |
      kind: InitConfiguration
      nodeRegistration:
        kubeletExtraArgs:
          node-labels: "ingress-ready=true"
    extraPortMappings:
    - containerPort: 80
      hostPort: 80
      protocol: TCP
    - containerPort: 443
      hostPort: 443
      protocol: TCP
    - containerPort: 30000
      hostPort: 30000
      protocol: TCP
    - containerPort: 30001
      hostPort: 30001
      protocol: TCP
  - role: worker
  - role: worker
EOF
    
    log_success "KIND cluster '$cluster_name' created successfully"
    
    # Set context and verify
    kubectl cluster-info --context "kind-${cluster_name}"
    log_info "Cluster info verified"
}

# Install ArgoCD with configuration options
install_argocd() {
    local cluster_name="$1"
    
    log_info "Installing ArgoCD on cluster: $cluster_name"
    
    # Create ArgoCD namespace
    kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -
    
    # Install ArgoCD
    kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
    
    # Configure ArgoCD server based on user choice
    if [ "$ARGOCD_SECURE" == "1" ]; then
        log_info "Configuring ArgoCD for insecure mode (local development)"
        kubectl patch deploy argocd-server -n argocd \
          --type='json' \
          -p='[{"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--insecure"}]'
    fi
    
    # Always enable gzip for better performance
    kubectl patch deploy argocd-server -n argocd \
      --type='json' \
      -p='[{"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--enable-gzip"}]'
    
    log_info "Waiting for ArgoCD to be ready..."
    kubectl wait --for=condition=available --timeout=300s \
        deployment/argocd-server -n argocd
    
    log_success "ArgoCD installed successfully"
}

# Deploy guestbook application
deploy_guestbook() {
    log_info "Deploying guestbook application..."
    
    # Create guestbook namespace
    kubectl create namespace guestbook --dry-run=client -o yaml | kubectl apply -f -
    
    # Apply guestbook manifests (assuming they exist in the repo)
    if [ -d "$REPO_ROOT/apps/guestbook" ]; then
        # Check if we have Kubernetes manifests or need to create them
        if [ -f "$REPO_ROOT/apps/guestbook/Dockerfile" ]; then
            log_info "Creating Kubernetes manifests for guestbook..."
            create_guestbook_manifests
        fi
        
        # Apply the manifests if they exist
        if [ -d "$REPO_ROOT/clusters/dev" ]; then
            kubectl apply -f "$REPO_ROOT/clusters/dev/" --recursive --ignore-not-found=true
        fi
    else
        log_warn "Guestbook app directory not found, skipping deployment"
    fi
    
    log_success "Guestbook deployment initiated"
}

# Create Kubernetes manifests for guestbook
create_guestbook_manifests() {
    local manifests_dir="$REPO_ROOT/clusters/dev"
    mkdir -p "$manifests_dir"
    
    # Create guestbook deployment
    cat > "$manifests_dir/guestbook-deployment.yaml" <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: guestbook
  namespace: guestbook
spec:
  replicas: 2
  selector:
    matchLabels:
      app: guestbook
  template:
    metadata:
      labels:
        app: guestbook
    spec:
      containers:
      - name: guestbook
        image: node:18-alpine
        workingDir: /app
        command: ["npm", "start"]
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: PORT
          value: "3000"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
        volumeMounts:
        - name: app-source
          mountPath: /app
      volumes:
      - name: app-source
        configMap:
          name: guestbook-source
EOF

    # Create guestbook service
    cat > "$manifests_dir/guestbook-service.yaml" <<EOF
apiVersion: v1
kind: Service
metadata:
  name: guestbook
  namespace: guestbook
spec:
  selector:
    app: guestbook
  ports:
  - port: 80
    targetPort: 3000
    nodePort: 30000
  type: NodePort
EOF

    log_success "Kubernetes manifests created"
}

# Save kubeconfig and display access information
finalize_setup() {
    local cluster_name="$1"
    
    log_info "Finalizing setup..."
    
    # Save kubeconfig
    kind export kubeconfig --name "$cluster_name" --kubeconfig "$KUBECONFIG_PATH"
    log_success "Kubeconfig saved to: $KUBECONFIG_PATH"
    
    # Get ArgoCD admin password
    local argocd_password
    argocd_password=$(KUBECONFIG="$KUBECONFIG_PATH" kubectl -n argocd get secret argocd-initial-admin-secret \
        -o jsonpath="{.data.password}" 2>/dev/null | base64 -d || echo "Password not ready yet")
    
    # Display access information
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                 Setup Complete!                           â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    log_success "ArgoCD Access Information:"
    echo "  ğŸŒ UI: https://localhost:8080 (after port-forward)"
    echo "  ğŸ‘¤ Username: admin"
    echo "  ğŸ” Password: $argocd_password"
    echo ""
    log_success "Quick Start Commands:"
    echo "  # Set kubeconfig"
    echo "  export KUBECONFIG=\"$KUBECONFIG_PATH\""
    echo ""
    echo "  # Port-forward ArgoCD UI"
    echo "  kubectl port-forward svc/argocd-server -n argocd 8080:443 &"
    echo ""
    echo "  # Check cluster status"
    echo "  kubectl get nodes"
    echo "  kubectl get pods -A"
    echo ""
    if [ "$DEMO_APPS" == "1" ]; then
        echo "  # Access guestbook (after deployment)"
        echo "  http://localhost:30000"
        echo ""
    fi
    log_success "Happy GitOps-ing! ğŸš€"
}

# Main execution flow
main() {
    print_banner
    echo ""
    
    log_info "Starting GitOps platform bootstrap for cluster: $CLUSTER_NAME"
    
    # Run setup steps
    check_prerequisites
    configure_deployment
    create_kind_cluster "$CLUSTER_NAME"
    install_argocd "$CLUSTER_NAME"
    
    if [ "$DEMO_APPS" == "1" ] || [ "$DEMO_APPS" == "2" ]; then
        deploy_guestbook
    fi
    
    # Handle multi-environment setup
    if [ "$ENV_SETUP" == "2" ]; then
        log_info "Setting up additional environments..."
        for env in staging prod; do
            read -p "Create $env cluster? (y/N): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                create_kind_cluster "$env"
                install_argocd "$env"
            fi
        done
    fi
    
    finalize_setup "$CLUSTER_NAME"
}

# Run main function
main "$@"
